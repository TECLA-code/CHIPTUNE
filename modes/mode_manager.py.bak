"""
ModeManager - Gestiona els diferents modes del TECLA i les transicions entre ells.
Utilitza ConfigManager per gestionar la configuració dels modes i els bancs.
"""
import time
import os
from core.config_manager import ConfigManager
from modes.base_mode import BaseMode

# Diccionari amb els modes disponibles i les seves classes
# Format: 'Nom del Mode': ('nom_fitxer_sense_extensio', 'NomClasse')
MODE_CLASSES = {
    'Silenci': ('mode_silenci', 'ModeSilenci'),
    'Riu': ('mode_rio', 'ModeRio'),
    'Tempesta': ('mode_tormenta', 'ModeTormenta'),
    'Matemàtic': ('mode_matematic_armonic', 'ModeMatematicArmonic'),
    'Mandelbrot': ('mode_mandelbrot', 'ModeMandelbrot'),
    'Jazz': ('mode_jazz_chords', 'ModeJazzChords'),
    'Ecos': ('mode_ecos_pasado', 'ModeEcosPasado'),
    'Rítmic': ('mode_ritmic_loop', 'ModeRitmicLoop'),
    'Sinusoidal': ('mode_ona_sinusoidal', 'ModeOnaSinusoidal'),
    'Dinamo': ('mode_dinamo', 'ModeDinamo'),
    'Cascada': ('mode_cascada', 'ModeCascada'),
    'Pèndol': ('mode_pendular', 'ModePendular'),
    'Caos': ('mode_caos_controlat', 'ModeCaosControlat'),
    'Vida': ('mode_vida', 'ModeVida'),
    'Ressonàncies': ('mode_resonancies', 'ModeResonancies'),
    'Acords': ('mode_acords_aleatoris', 'ModeAcordsAleatoris')
}

# Constants
MODE_CHANGE_DELAY = 0.5  # segons per evitar canvis accidentals

class ModeManager:
    """Gestiona tots els modes d'operació i les transicions entre ells.
    
    Aquest gestor s'encarrega de:
    - Carregar tots els modes disponibles
    - Gestionar les transicions entre modes
    - Mantenir l'estat actual del sistema
    - Gestionar la configuració i els bancs de modes
    """
    
    def __init__(self, midi_out, config_path='config/tecla_config.json'):
        """Inicialitza el ModeManager.
        
        Args:
            midi_out: Instància de sortida MIDI
            config_path: Ruta al fitxer de configuració
        """
        self.midi_out = midi_out
        self.modes = {}  # Diccionari de modes carregats: {nom: instància}
        self.current_mode = None
        self.current_mode_name = None
        self.last_mode_change = time.monotonic()
        
        # Inicialitzar el gestor de configuració
        self.config_manager = ConfigManager(config_path)
        
        # Carregar tots els modes disponibles
        self._load_all_modes()
        
        # Inicialitzar amb el mode Silenci per defecte si està disponible
        if 'Silenci' in self.modes:
            self.set_mode('Silenci')
    
    def _load_all_modes(self):
        """Carrega tots els modes definits a MODE_CLASSES.
        
        Aquest mètode s'executa durant la inicialització per carregar
        dinàmicament tots els modes definits al diccionari MODE_CLASSES.
        """
        # Comptadors per a estadístiques
        total_modes = len(MODE_CLASSES)
        loaded_modes = 0
        failed_modes = 0
        
        # Prioritzar el mode Silenci per carregar-lo primer
        mode_items = sorted(MODE_CLASSES.items(), 
                           key=lambda x: 0 if x[0] == 'Silenci' else 1)
        
        for mode_name, (module_name, class_name) in mode_items:
            try:
                # Carregar el mòdul i la classe dinàmicament amb gestió d'errors millorada
                try:
                    module = __import__(f'modes.{module_name}')
                    module = getattr(module, module_name)  # Obtenir el submòdul
                except ImportError as ie:
                    print(f"✗ No s'ha trobat el mòdul {module_name}: {ie}")
                    failed_modes += 1
                    continue
                except AttributeError as ae:
                    print(f"✗ Error accedint al submòdul {module_name}: {ae}")
                    failed_modes += 1
                    continue
                
                try:
                    mode_class = getattr(module, class_name)
                except AttributeError as ae:
                    print(f"✗ No s'ha trobat la classe {class_name} al mòdul {module_name}: {ae}")
                    failed_modes += 1
                    continue
                
                # Crear i inicialitzar la instància del mode
                try:
                    mode_instance = mode_class(self.midi_out, {})
                    self.modes[mode_name] = mode_instance
                    
                    # Inicialitzar el mode si té mètode setup
                    if hasattr(mode_instance, 'setup'):
                        mode_instance.setup()
                    
                    print(f"✓ Mode carregat: {mode_name}")
                    loaded_modes += 1
                    
                except Exception as e:
                    print(f"✗ Error inicialitzant el mode {mode_name}: {e}")
                    failed_modes += 1
                    
            except Exception as e:
                print(f"✗ Error inesperat carregant el mode {mode_name} ({module_name}.{class_name}): {e}")
                failed_modes += 1
                try:
                    import sys
                    sys.print_exception(e)  # Específic de CircuitPython
                except Exception:
                    pass  # Ignorar si no es pot mostrar més informació
        
        # Mostrar resum de la càrrega
        print(f"\nResum de càrrega de modes: {loaded_modes}/{total_modes} carregats correctament")
        if failed_modes > 0:
            print(f"  {failed_modes} modes no s'han pogut carregar")
            
        # Assegurar que sempre hi hagi almenys un mode disponible
        if not self.modes:
            print("\nAvís: No s'ha pogut carregar cap mode. Creant mode Silenci per defecte...")
            from modes.mode_silenci import ModeSilenci
            self.modes['Silenci'] = ModeSilenci(self.midi_out, {})
                
    def _get_active_modes(self, bank):
        """Retorna la llista de modes actius per a un banc, excloent els desactivats
        
        Args:
            bank: Diccionari amb la configuració del banc
            
        Returns:
            list: Llista de modes actius (màxim 16)
        """
        # Validació d'entrada
        if not bank or not isinstance(bank, dict):
            print("Avís: Banc invàlid o no disponible")
            return []
            
        try:
            # Obtenir llistes de modes
            all_modes = bank.get('modes', [])
            if not all_modes:
                print(f"Avís: El banc {bank.get('name', 'desconegut')} no té modes definits")
                return []
                
            disabled_modes = bank.get('disabled_modes', [])
            
            # Filtrar els modes desactivats i verificar que existeixen
            active_modes = []
            for mode in all_modes:
                # Comprovar si el mode està desactivat
                if mode in disabled_modes:
                    continue
                    
                # Comprovar si el mode existeix
                if mode in self.modes:
                    active_modes.append(mode)
                else:
                    print(f"Avís: El mode '{mode}' no existeix i serà ignorat")
            
            # Limitar a 16 modes (nombre de botons disponibles)
            if len(active_modes) > 16:
                print(f"Avís: Hi ha {len(active_modes)} modes actius, però només es poden utilitzar 16")
                active_modes = active_modes[:16]
                
            return active_modes
            
        except Exception as e:
            print(f"Error obtenint modes actius: {e}")
            return []
    
    def get_available_modes(self):
        """Retorna una llista amb tots els modes disponibles"""
        return list(self.modes.keys())
    
    def change_bank(self):
        """Canvia al següent banc de modes"""
        return self.config_manager.next_bank()
    
    def get_current_bank_name(self):
        """Retorna el nom del banc actual"""
        bank = self.config_manager.get_current_bank()
        return bank['name'] if bank else 'Desconegut'
    
    def get_available_banks(self):
        """Retorna la llista de tots els bancs disponibles"""
        return self.config_manager.get_available_banks()
    
    def set_mode(self, mode_name):
        """Canvia al mode especificat.
        
        Args:
            mode_name: Nom del mode al qual canviar
            
        Returns:
            bool: True si el canvi va tenir èxit, False en cas contrari
        """
        current_time = time.monotonic()
        
        # Evitar canvis massa ràpids
        if current_time - self.last_mode_change < MODE_CHANGE_DELAY:
            print(f"Avís: Ignorant canvi de mode massa ràpid a {mode_name}")
            return False
            
        # Verificar que el mode existeix
        if mode_name not in self.modes:
            print(f"✗ Mode no trobat: {mode_name}")
            return False
            
        # Si ja estem en aquest mode, no cal canviar
        if self.current_mode_name == mode_name:
            return True
            
        # Actualitzar timestamp de canvi
        self.last_mode_change = current_time
        
        # Aturar el mode actual
        if self.current_mode:
            print(f"Aturant mode: {self.current_mode_name}")
            self._stop_current_mode()
        
        # Iniciar el nou mode (amb gestió d'errors)
        success = False
        try:
            # Assignar el nou mode
            print(f"Iniciant mode: {mode_name}")
            self.current_mode = self.modes[mode_name]
            self.current_mode_name = mode_name
            
            # Inicialitzar el nou mode si cal
            if hasattr(self.current_mode, 'setup'):
                self.current_mode.setup()
                
            print(f"Mode canviat correctament a: {mode_name}")
            success = True
            
        except Exception as e:
            print(f"Error en canviar al mode {mode_name}: {e}")
            # En cas d'error, intentar tornar al mode Silenci
            if mode_name != 'Silenci' and 'Silenci' in self.modes:
                print("Tornant al mode Silenci per seguretat...")
                try:
                    self.current_mode = self.modes['Silenci']
                    self.current_mode_name = 'Silenci'
                    if hasattr(self.current_mode, 'setup'):
                        self.current_mode.setup()
                except Exception as e2:
                    print(f"Error tornant al mode Silenci: {e2}")
        
        return success
        
    def _stop_current_mode(self):
        """Atura el mode actual i neteja els seus recursos.
        
        Aquest mètode s'encarrega d'aturar correctament el mode actual,
        cridant al seu mètode cleanup() i aturant totes les notes actives.
        """
        if not self.current_mode:
            return
            
        # Guardar una referència al nom del mode per si hi ha errors
        mode_name = self.current_mode_name
        
        # Cridar al mètode cleanup del mode
        if hasattr(self.current_mode, 'cleanup'):
            notes_to_stop = None
            try:
                notes_to_stop = self.current_mode.cleanup()
            except Exception as e:
                print(f"Error en el mètode cleanup del mode {mode_name}: {e}")
                # Intent d'aturar totes les notes en cas d'error
                self._panic()
                return
                
            # Aturar les notes retornades pel mètode cleanup
            if notes_to_stop:
                self._stop_notes(notes_to_stop)
        else:
            print(f"Avís: El mode {mode_name} no té mètode cleanup()")
            # Aturar totes les notes per seguretat
            self._panic()
    
    def _stop_notes(self, notes_info):
        """Atura les notes especificades.
        
        Args:
            notes_info: Llista de tuples (note, velocity) o (note, velocity, channel)
                        o simplement una llista de notes si velocity i channel són per defecte
        """
        if not notes_info:
            return
            
        # Comprovar si notes_info és una llista de tuples o simplement una llista de notes
        if not isinstance(notes_info, list):
            print(f"Avís: Format de notes_info invàlid: {type(notes_info)}")
            return
            
        # Comptadors per a estadístiques
        total_notes = len(notes_info)
        stopped_notes = 0
        failed_notes = 0
        
        for note_info in notes_info:
            try:
                # Cas 1: note_info és una tupla (note, velocity) o (note, velocity, channel)
                if isinstance(note_info, (tuple, list)):
                    if len(note_info) >= 2:  # Mínim (note, velocity)
                        note = note_info[0]
                        velocity = note_info[1]
                        channel = note_info[2] if len(note_info) > 2 else 0
                        
                        # Validar els valors
                        if not (0 <= note <= 127 and 0 <= velocity <= 127 and 0 <= channel <= 15):
                            print(f"Avís: Valors MIDI fora de rang: {note_info}")
                            note = max(0, min(127, note))
                            velocity = max(0, min(127, velocity))
                            channel = max(0, min(15, channel))
                            
                        # Enviar missatge MIDI
                        self.midi_out.send(self.note_off(note, velocity, channel))
                        stopped_notes += 1
                    else:
                        print(f"Avís: Tupla de nota massa curta: {note_info}")
                        failed_notes += 1
                        
                # Cas 2: note_info és simplement un número de nota
                elif isinstance(note_info, (int, float)):
                    note = int(note_info)
                    if 0 <= note <= 127:
                        self.midi_out.send(self.note_off(note, 0, 0))
                        stopped_notes += 1
                    else:
                        print(f"Avís: Nota fora de rang: {note}")
                        failed_notes += 1
                else:
                    print(f"Avís: Format de nota invàlid: {type(note_info)}")
                    failed_notes += 1
                    
            except Exception as e:
                print(f"Error aturant nota {note_info}: {e}")
                failed_notes += 1
                
        # Mostrar resum si hi ha hagut errors
        if failed_notes > 0:
            print(f"Resum d'aturada de notes: {stopped_notes}/{total_notes} aturades correctament")
            print(f"  {failed_notes} notes no s'han pogut aturar")
            
        # Petita pausa per assegurar que s'envien totes les dades
        if stopped_notes > 0:
            time.sleep(0.01)
    
    def update(self, pot_values, button_states):
        """Actualitza l'estat actual del mode.
        
        Args:
            pot_values: Llista amb els valors dels potenciòmetres [x, y, z]
            button_states: Llista amb els estats dels botons [b0, b1, ..., b15]
            
        Returns:
            dict: Diccionari amb l'estat actualitzat del mode
        """
        # Validació bàsica d'entrades
        if not isinstance(pot_values, list) or not isinstance(button_states, list):
            print(f"Avís: Format d'entrada invàlid - pot_values: {type(pot_values)}, button_states: {type(button_states)}")
            return {'mode': 'Error: Format d\'entrada invàlid', 'bank': '--'}
            
        # Verificar que hi ha un mode actiu
        if not self.current_mode:
            return {'mode': 'Cap mode actiu', 'bank': '--'}
        
        # Obtenir el banc actual amb gestió d'errors
        bank_name = '--'
        current_bank = None
        try:
            current_bank = self.config_manager.get_current_bank()
            if not current_bank:
                return {'mode': 'Error: No hi ha bancs disponibles', 'bank': '--'}
            bank_name = current_bank.get('name', '--')
        except Exception as e:
            print(f"Error obtenint el banc actual: {e}")
            # Continuar amb valors per defecte
        
        # Comprovar canvis de mode per botons si tenim un banc vàlid
        if current_bank:
            try:
                self._check_mode_changes(button_states, current_bank)
            except Exception as e:
                print(f"Error comprovant canvis de mode: {e}")
        
        # Preparar valors segurs per als potenciòmetres
        safe_pot_values = [0, 0, 0]  # Valors per defecte
        try:
            # Assegurar que els valors estan dins dels rangs esperats
            safe_pot_values = [max(0, min(127, v)) for v in pot_values[:3]] if pot_values else [0, 0, 0]
            while len(safe_pot_values) < 3:  # Assegurar que hi ha 3 valors
                safe_pot_values.append(0)
        except Exception as e:
            print(f"Error preparant valors dels potenciòmetres: {e}")
        
        # Actualitzar el mode actual amb nous valors
        try:
            # Actualitzar el mode
            status = self.current_mode.update(safe_pot_values, button_states)
            
            # Afegir informació del banc
            if isinstance(status, dict):
                status['bank'] = bank_name
                status['mode'] = self.current_mode_name
                return status
            else:
                # Si el mode no retorna un diccionari, crear-ne un
                return {
                    'mode': self.current_mode_name,
                    'bank': bank_name,
                    'status': str(status) if status is not None else 'OK'
                }
                
        except Exception as e:
            print(f"Error actualitzant el mode {self.current_mode_name}: {e}")
            
            # Intent de recuperació en cas d'error greu
            if 'Silenci' in self.modes and self.current_mode_name != 'Silenci':
                try:
                    print("Intent de recuperació: Canviant al mode Silenci...")
                    self.set_mode('Silenci')
                except Exception as e2:
                    print(f"Error canviant al mode Silenci: {e2}")
            
            # Retornar un estat d'error però continuar funcionant
            return {
                'mode': self.current_mode_name,
                'bank': bank_name,
                'error': str(e)
            }
    
    def _check_mode_changes(self, button_states, current_bank):
        """Comprova si s'ha premut algun botó per canviar de mode.
        
        Args:
            button_states: Llista d'estats dels botons
            current_bank: Banc actual de configuració
        """
        # Validació d'entrades
        if not button_states or not current_bank:
            return
            
        try:
            # Obtenir els modes actius del banc actual
            active_modes = self._get_active_modes(current_bank)
            if not active_modes:
                return
                
            # Comprovar si algun botó està premut per canviar de mode
            for i, pressed in enumerate(button_states):
                if not pressed:
                    continue  # Saltar botons no premuts
                    
                if i >= len(active_modes):
                    break  # No hi ha més modes disponibles
                    
                mode_name = active_modes[i]
                
                # Verificar que el mode existeix i no és l'actual
                if mode_name in self.modes and mode_name != self.current_mode_name:
                    # Comprovar si el mode està desactivat
                    disabled_modes = current_bank.get('disabled_modes', [])
                    if mode_name in disabled_modes:
                        print(f"Avís: El mode {mode_name} està desactivat")
                        continue
                        
                    # Canviar al nou mode
                    print(f"Botó {i} premut: Canviant al mode {mode_name}")
                    self.set_mode(mode_name)
                    break
                    
        except Exception as e:
            print(f"Error en comprovar canvis de mode: {e}")
            # No propagar l'error per no interrompre el funcionament
    
    def cleanup(self):
        """Neteja tots els recursos utilitzats pels modes.
        
        Aquest mètode s'ha de cridar abans de sortir de l'aplicació
        per assegurar que totes les notes s'aturin correctament i
        que es netegin tots els recursos.
        
        Returns:
            list: Llista buida (per compatibilitat)
        """
        print("Netejant recursos del gestor de modes...")
        
        # Aturar el mode actual
        if self.current_mode:
            print(f"Aturant mode actual: {self.current_mode_name}")
            self._stop_current_mode()
        
        # Enviar senyals MIDI per aturar totes les notes
        print("Enviant MIDI panic...")
        try:
            self._panic()
        except Exception as e:
            print(f"Error en MIDI panic: {e}")
        
        # Netejar tots els modes carregats
        for mode_name, mode in self.modes.items():
            if hasattr(mode, 'cleanup') and mode != self.current_mode:
                try:
                    print(f"Netejant recursos del mode: {mode_name}")
                    mode.cleanup()
                except Exception as e:
                    print(f"Error netejant el mode {mode_name}: {e}")
        
        # Desar la configuració si cal
        try:
            self.config_manager.save_config()
        except Exception as e:
            print(f"Error desant la configuració: {e}")
            
        print("Neteja de recursos completada")
        
        # Netejar referències
        self.current_mode = None
        self.current_mode_name = None
        
        return []
    
    def _panic(self):
        """Atura totes les notes MIDI en tots els canals.
        
        Aquest mètode envia missatges de control MIDI per aturar totes les notes
        i sons en tots els canals. És una mesura de seguretat per evitar notes
        que es queden sonant indefinidament.
        """
        # Intentar mètode principal
        error_occurred = False
        
        # Enviar All Notes Off i All Sound Off a tots els canals
        for channel in range(16):
            # Enviar missatges de control per aturar tots els sons
            try:
                self.midi_out.send(self.control_change(123, 0, channel))  # All Notes Off
                self.midi_out.send(self.control_change(120, 0, channel))  # All Sound Off
                self.midi_out.send(self.control_change(121, 0, channel))  # Reset All Controllers
            except Exception as e:
                print(f"Error enviant control change al canal {channel}: {e}")
                error_occurred = True
        
        # Si hi ha hagut errors, intentar el mètode alternatiu
        if error_occurred:
            try:
                from adafruit_midi.note_off import NoteOff
                from adafruit_midi.control_change import ControlChange
                
                # Enviar All Notes Off directament
                for channel in range(16):
                    self.midi_out.send(ControlChange(123, 0, channel))
            except Exception as e:
                print(f"Error en el mètode alternatiu de panic MIDI: {e}")
        
        # Petita pausa per assegurar que s'envien totes les dades
        time.sleep(0.2)
    
    def note_off(self, note, velocity=0, channel=0):
        """Retorna un missatge de nota OFF MIDI.
        
        Args:
            note: Número de nota (0-127)
            velocity: Velocitat de la nota (0-127)
            channel: Canal MIDI (0-15)
            
        Returns:
            objecte NoteOff de adafruit_midi
        """
        from adafruit_midi.note_off import NoteOff
        return NoteOff(min(max(0, note), 127), min(max(0, velocity), 127), channel=min(max(0, channel), 15))
    
    def control_change(self, control, value, channel=0):
        """Retorna un missatge de control canvi MIDI.
        
        Args:
            control: Número de control (0-127)
            value: Valor del control (0-127)
            channel: Canal MIDI (0-15)
            
        Returns:
            objecte ControlChange de adafruit_midi
        """
        from adafruit_midi.control_change import ControlChange
        return ControlChange(
            min(max(0, control), 127),
            min(max(0, value), 127),
            channel=min(max(0, channel), 15)
        )
    
    def get_available_modes(self):
        """Retorna una llista amb tots els modes disponibles.
        
        Returns:
            list: Llista de noms de modes disponibles
        """
        return list(self.modes.keys())
    
    def change_bank(self):
        """Canvia al següent banc de modes.
        
        Returns:
            bool: True si el canvi va tenir èxit, False en cas contrari
        """
        return self.config_manager.next_bank()
    
    def get_current_bank_name(self):
        """Retorna el nom del banc actual.
        
        Returns:
            str: Nom del banc actual o 'Desconegut' si no n'hi ha cap
        """
        bank = self.config_manager.get_current_bank()
        return bank.get('name', 'Desconegut') if bank else 'Desconegut'
    
    def get_available_banks(self):
        """Retorna la llista de tots els bancs disponibles.
        
        Returns:
            list: Llista de noms de bancs disponibles
        """
        return self.config_manager.get_available_banks()
    

    
    def get_current_mode_info(self):
        """Retorna informació sobre el mode actual"""
        if not self.current_mode:
            return {'name': 'Cap mode actiu', 'description': '', 'version': '0.0'}
            
        return self.current_mode.get_mode_info()
    
    def get_all_modes(self):
        """Retorna una llista amb tots els noms dels modes disponibles"""
        return list(self.modes.keys())
